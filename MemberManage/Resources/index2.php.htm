<html>
	<head>
		<title>Dev Articles</title>
		<script src="index2.php_files/urchin.js" type="text/javascript"> 
		</script>
		<script type="text/javascript">
_uacct = "UA-290307-1";
urchinTracker();
		</script>
		<link rel="stylesheet" href="index2.php_files/template_css.css" type="text/css">
			<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body class="contentpane">
		<script language="JavaScript" type="text/javascript">
<!--
// #############################################################################
// AD Server stuff
function zeustool(zoneid)
{
if (!document.dragon_used) document.dragon_used = ',';
   dragon_random = new String (Math.random()); dragon_random = dragon_random.substring(2,11);
   
   document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
   document.write ("http://zeus.developershed.com/master.php?n=" + dragon_random);
   document.write ("&amp;what=zone:"+zoneid);
   document.write ("&amp;exclude=" + document.dragon_used);
   if (document.referrer)
      document.write ("&amp;referer=" + escape(document.referrer));
   document.write ("'><" + "/script>");
}
//-->
		</script>
		<table class="contentpaneopen" border="0" cellpadding="0" cellspacing="1" width="100%">
			<tbody>
				<tr>
					<td valign="top" width="100%">
						<!-- Content next to Island Unit Goes here -->
						<table cellpadding="0" cellspacing="0" width="100%">
							<tbody>
								<tr>
									<td width="100%"><h2>C#</h2>
									</td>
								</tr>
								<tr>
									<td class="colorbar" height="5" width="100%"></td>
								</tr>
							</tbody></table>
						<br>
						<a rel="nofollow" href="http://www.devarticles.com/c/a/C-Sharp/Printing-Using-C-sharp/"
							class="title_readon">Printing Using C#</a>
						<br>
						<span class="content_rating"> Contributed by <a rel="nofollow" href="http://www.devarticles.com/cp/bio/Wrox-Team/">
								Wrox Team</a></span><br>
						<span class="content_rating">2003-01-27</span> <!-- End of Content next to Island Unit -->
					</td>
					<td width="16">&nbsp;</td>
					<td width="282">
						<table border="1" cellpadding="1" cellspacing="0" width="100">
							<tbody>
								<tr>
									<td>
										<!-- Article Box -->
										<a rel="nofollow" target="_blank" href="http://zeus.developershed.com/shonuff.php?blackbird=4287&amp;zoneid=179&amp;source=&amp;dest=http%3A%2F%2Fsend.onenetworkdirect.net%2Fz%2F9372%2FCD61378%2F&amp;ismap=">
											<img src="index2.php_files/9372.gif" alt="Spyware Doctor" border="0"></a><div id="beacon_4287" style="LEFT: 0px; VISIBILITY: hidden; POSITION: absolute; TOP: 0px"><img src="index2.php_files/adlog.gif" alt="" style="DISPLAY: none; WIDTH: 0px; HEIGHT: 0px"
												height="0" width="0"></div> <!-- End Article Box -->
									</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr>
					<td colspan="3">
						<table border="0" cellpadding="0" cellspacing="0" width="100%">
							<tbody>
								<tr>
									<td height="13"><img style="DISPLAY: none" src="index2.php_files/advertisement2.gif" height="13" width="85"></td>
								</tr>
								<tr>
									<td height="40"><font face="Arial, Helvetica, sans-serif" size="2"> 
											<!-- Article Paragraph -->
											<b>New! <a rel="nofollow" target="_blank" href="http://zeus.developershed.com/shonuff.php?blackbird=4323&amp;zoneid=160&amp;source=&amp;dest=http%3A%2F%2Fsend.onenetworkdirect.net%2Fz%2F32%2FCD61378%2F&amp;ismap=">
													Norton Antivirus 2008</a></b> has the advanced protection you need to 
											shield your computer from today's evolving internet threats. Block Viruses and 
											Spyware with advanced protection.<div id="beacon_4323" style="LEFT: 0px; VISIBILITY: hidden; POSITION: absolute; TOP: 0px"><img src="index2.php_files/adlog_002.gif" alt="" style="DISPLAY: none; WIDTH: 0px; HEIGHT: 0px"
													height="0" width="0"></div> <!-- End Article paragraph -->
										</font>
									</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr>
					<td height="1"><img src="index2.php_files/spacer.gif" height="2" width="1"></td>
				</tr>
				<tr>
					<td colspan="3" background="index2.php_files/line_dot.gif" height="1"><img src="index2.php_files/spacer.gif" height="1" width="1"></td>
				</tr>
			</tbody></table>
		<br>
		<table border="0" cellpadding="0" cellspacing="0">
			<tbody>
				<tr>
					<td valign="top">
						<span class="txt">
							<div id="intelliTxt">
								In this article Matthew shows us how to build a print engine in C# allowing us 
								to print our application data easily.<b>Editor's Note: This article's code has been 
									updated to work with the final release of the .Net framework.</b>
								<br>
								<br>
								Those of you who have done any programming with the Win32 API will be familiar 
								with the concept of the Device Context, also known as the "DC". A Device 
								Context allows a developer to draw things like text, lines, rectangles, curves, 
								etc. on both the screen and the printer, or even in memory in preparation for 
								later drawing to either of these devices. This was a pretty powerful 
								arrangement that allowed a developer who knew how to draw application output on 
								the screen to draw application output on a printer.
								<br>
								<br>
								With .NET, we're given a variety of graphics classes that eventually allow 
								drawing of certain graphics primitives onto device contexts. This article 
								describes how we can build an application that is capable of printing its 
								output on a printer installed on the computer, allow the adjustment of page and 
								printer settings and also provide a print preview. Part of the difficulty of 
								printing from an application is that we lose the concept of using controls to 
								present our program's output to the user. To clarify, with a VB.NET or C# 
								application, if we're building a UI we usually do so by painting controls on 
								the screen and allowing whoever developed them to worry about the whys and 
								wherefores about how that control should look. We don't really care how many 
								individual DrawLine calls it takes to draw a button on the screen.
								<br>
								<br>
								With printing, you lose this control-oriented abstraction and you have to get 
								back to worry about where to draw lines, selecting fonts, drawing text and so 
								on. This makes life difficult for developers maintaining and enhancing the 
								application.
								<br>
								<br>
								Imagine you have an application that prints simple reports and in this 
								application you have a class called Customer that represents a customer. As 
								part of the report, you want to print all of the customer's details. What the 
								developer wants is a really easy to use framework where she can just say, "Now 
								print the customer's name" or "Print the URL of the customer's home page". She 
								doesn't want to have to worry about where exactly on the page to position the 
								text, or which font to use, just like as a UI developer using controls you 
								don't care about how to find out the default color for the button.
								<br>
								<br>
								In this article we're going to build a fairly powerful printing framework that 
								can be easily enhanced at a later date. We're going to provide the developer 
								with such elements as print previews, printer settings and we're also going to 
								take over all the hard work of pagination, adding headers and footers and so 
								on. (For the uninitiated, "pagination" is the process of splitting up a 
								document into pages and laying out each page so that it matches the layout that 
								the user intended.)
								<br>
								<br>
								<b>Objects, Elements and Primitives</b>
								<br>
								<br>
								Let's assume that our application has access to objects that describe things, 
								such as Customer, Company, Order and Product. Let's also assume that our 
								reports are going to be fairly simple lists of these object, e.g. "Give me a 
								list of all customers who have ordered from me today."
								<br>
								<br>
								Our report might look like this:
								<br>
								<br>
								<div align="center"><img alt="Screenshot" src="index2.php_files/print_csharp_1.gif"></div>
								<br>
								<br>
								One way to break up this task is to say that we're going to build a page up of 
								different "elements". In the above screenshot, we have three elements:
								<br>
								<br>
								<div align="center"><img alt="Screenshot" src="index2.php_files/print_csharp_2.gif"></div>
								<br>
								<br>
								The elements we have, "Header", "Customer" and "Footer", are all comprised of 
								different "primitives." In this case, we have two kinds of primitives: "text" 
								and "horizontal rule".
								<br>
								<br>
								So, to build up our application we first of all need an object that describes 
								the print functionality. We'll call this PrintEngine and this object will be 
								responsible for laying out the elements on the page and choosing when new pages 
								need to be added to the report. Each element will be represented by a 
								PrintElement object. This PrintElement object will know how to contain 
								primitives, specifically PrintPrimitiveText and PrintPrimitiveRule objects.
								<br>
								<br>
								It will be these objects that know how to draw themselves on the page and 
								report back to PrintEngine as to their size. (In order for PrintEngine to lay 
								out the elements, it needs to know how large each element is. To determine an 
								elements size, the primitives have to be able to report on their size.)
								<br>
								<br>
								Now that we know what we're trying to achieve, let's look at building an 
								application capable of printing. We'll build the printing components of this 
								application in such a way that we could extract them and reuse them in another 
								project.
								<br>
								Create a new Visual C# - Windows Application project now and call it Printing. 
								Add these controls to Form1:
								<br>
								<br>
								<div align="center"><img alt="Screenshot" src="index2.php_files/print_csharp_3.gif"></div>
								<br>
								<br>
								Here are the controls:
								<br>
								<ul>
									<li>
										<b>trackCustomers</b>
									- this slider bar should have a minimum value of 0 and a maximum value of 128. 
									Set Value to 1.<li><b>cmdPrintPreview</b>
									- the print preview button.<li><b>cmdPageSettings</b>
									- the page settings button.<li><b>cmdPrint</b> - the print button.</li></ul>
								That's all there is to the form. Let's now look at building the rest of the 
								classes.
								<br>
								<br>
								<span class="headBlueSmall">"PrintEngine"</span>
								<br>
								<br>
								The Framework provides a class called PrintDocument that encapsulates 
								everything related to printing. Those of you who have used MFC, don't worry too 
								much about the word "document". There's nothing related to the "document/view" 
								model you might be thinking of. The "document" is simply something that you 
								want to print.
								<br>
								<br>
								To use this class you have two options: either respond to events fired by the 
								class or inherit from the class and build upon the functionality. In this 
								instance, we're going to inherit from it. Create a new class called PrintEngine 
								and add these:
								<br>
								<br>
								<span class="bodyCode">using statements: <br>using System; <br>using System.Collections; <br>using System.Drawing; <br>using System.Drawing.Printing; <br>using System.Windows.Forms;</span>
								<br>
								<br>
								Next, derive PrintEngine from PrintDocument:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;public class PrintEngine : PrintDocument</span>
								<br>
								<br>
								This project is a little "chicken and egg", so we'll be jumping between classes 
								as we try and build up the example. Perhaps the best place to start is 
								maintaining a list of the objects that we want to include on the report.
								<br>
								<br>
								As we build the report, we'll add Customer objects to an ArrayList maintained 
								in PrintEngine. Whenever we want to print the report, or display a preview, 
								we'll use methods to add objects that understand how to print themselves to 
								this ArrayList.
								<br>
								<br>
								Add this member to PrintEngine:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;public class PrintEngine : PrintDocument <br>&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;private ArrayList _printObjects = new ArrayList();</span>
								<br>
								<br>
								In a moment, we'll build an interface called IPrintable that an object must 
								support if it wants to be printed by PrintEngine. Add this method to 
								PrintEngine that accepts an object supporting this interface and adds it to 
								_printObjects:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// AddPrintObject - add a print object the document... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void AddPrintObject(IPrintable printObject) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_printObjects.Add(printObject); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								Now, create a new class called IPrintable and add this code:
								<br>
								<br>
								<span class="bodyCode">using System; <br><br>namespace Printing <br>{ <br>&nbsp;&nbsp;public interface IPrintable <br>&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;// Print <br>&nbsp;&nbsp;&nbsp;&nbsp;void Print(PrintElement element); <br>&nbsp;&nbsp;} <br>}</span>
								<br>
								<br>
								As you can see, our interface only has a single method: Print. You'll also 
								notice that it takes a parameter of PrintElement type. We haven't built that 
								yet, but it will represent a single instance of an element on a page. Bear with 
								me until we get to it!
								<br>
								<br>
								To complete this circle, create a new object called Customer. Add these 
								members:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;public class Customer : IPrintable <br>&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;// members... <br>&nbsp;&nbsp;&nbsp;&nbsp;public int Id; <br>&nbsp;&nbsp;&nbsp;&nbsp;public String FirstName; <br>&nbsp;&nbsp;&nbsp;&nbsp;public String LastName; <br>&nbsp;&nbsp;&nbsp;&nbsp;public String Company; <br>&nbsp;&nbsp;&nbsp;&nbsp;public String Email; <br>&nbsp;&nbsp;&nbsp;&nbsp;public String Phone; <br>&nbsp;&nbsp;}</span>
								<br>
								<br>
								As we've told Customer that it must support IPrintable, we need to implement 
								the method. However, we won't build any print functionality in just yet. Add 
								this method to Customer:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// Print... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void Print(PrintElement element) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								OK, so we're now at a point where we can create instances of a class called 
								Customer that, because it implements IPrintable, we can use 
								PrintEngine.AddPrintObject to add it to the final document. Let's look now at 
								building up the primitives and then take a look at implementing the elements 
								themselves. We're only going to implement two kinds of primitives in this 
								exercise: one that prints text, and one that prints a horizontal line. This 
								will let us build up a basic report.
								<br>
								<br>
								A primitive has to be able to do two things. It must be able to determine how 
								much space it will take up on the page and it must be able to draw itself on 
								whatever graphics context we've been given. This will either be on the printer, 
								or alternatively will be on the screen for a print preview - although we won't 
								actually care which is being used when we're asked to draw ourselves.
								<br>
								<br>
								Our two primitive classes will both implement IPrintPrimitive. This new 
								interface will define the two methods used to measure and draw the primitives. 
								Create a new class called IPrintPrimitive and add this code:
								<br>
								<br>
								<span class="bodyCode">using System; <br>using System.Drawing; <br><br>namespace Printing <br>{ <br>&nbsp;&nbsp;public interface IPrintPrimitive <br>&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;// CalculateHeight - work out how tall the primitive is... <br>&nbsp;&nbsp;&nbsp;&nbsp;float CalculateHeight(PrintEngine engine, Graphics graphics); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;// Print - tell the primitive to physically draw itself... <br>&nbsp;&nbsp;&nbsp;&nbsp;void Draw(PrintEngine engine, float yPos, Graphics graphics, Rectangle elementBounds); <br>&nbsp;&nbsp;} <br>}</span>
								<br>
								<br>
								Let's take a look at PrintPrimitiveRule, the class responsible for drawing a 
								horizontal rule. Create a new class called PrintPrimitiveRule and set the class 
								to implement IPrintPrimitive:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;public class PrintPrimitiveRule : IPrintPrimitive</span>
								<br>
								<br>
								This primitive is always going to be five drawing units high, so add this 
								method that will tell anyone who asks that we're five units high:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// CalculateHeight - work out how tall the primitive is... <br>&nbsp;&nbsp;&nbsp;&nbsp;public float CalculateHeight(PrintEngine engine, Graphics graphics) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// we're always five units tall... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 5; <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								When we come to draw the primitive, we're going to provide it with details of 
								the position on the page where it should draw itself. elementBounds describes a 
								rectangle that encloses the entire element. yPos describes the current 
								y-coordinate that should be used for drawing. These two in combination tell the 
								primitive where to draw itself, which it can do by using methods on the 
								supplied System.Drawing.Graphics object.
								<br>
								<br>
								Add this method to PrintPrimitiveRule that will draw a line two drawing units 
								down from where the primitive is supposed to start:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// Print - draw the rule... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void Draw(PrintEngine engine, float yPos, Graphics graphics, Rectangle elementBounds) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// draw a line... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pen pen = new Pen(engine.PrintBrush, 1); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;graphics.DrawLine(pen, elementBounds.Left, yPos + 2, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elementBounds.Right,
yPos + 2); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								The PrintPrimitiveText is very similar. Create the new class now and add the 
								same namespace declarations as before:
								<br>
								<br>
								<span class="bodyCode">using System; <br>using System.Drawing;</span>
								<br>
								<br>
								Then, tell the class to inherit IPrintPrimitive:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;public class PrintPrimitiveText : IPrintPrimitive</span>
								<br>
								<br>
								The class will also need a String member that contains the text that need to be 
								printed. We'll change the constructor of the class so that we need to supply 
								the text whenever we create one of the objects:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// members... <br>&nbsp;&nbsp;&nbsp;&nbsp;public String Text; <br><br>&nbsp;&nbsp;&nbsp;&nbsp;public PrintPrimitiveText(String buf) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Text = buf; <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								In a short while we'll add a member to PrintEngine called PrintFont. This will 
								contain a reference to a System.Drawing.Font object that will be used to draw 
								text on the report. We can use the Font object to measure the height of the 
								primitive, although we're going to assume that a single primitive cannot span 
								more than one line:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// CalculateHeight - work out how tall the primitive is... <br>&nbsp;&nbsp;&nbsp;&nbsp;public float CalculateHeight(PrintEngine engine, Graphics graphics) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// return the height... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return engine.PrintFont.GetHeight(graphics); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								In a similar manner to drawing the line, we can use the Graphics object to draw 
								the text:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// Print - draw the text... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void Draw(PrintEngine engine, float yPos, Graphics graphics, Rectangle elementBounds) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// draw it... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;graphics.DrawString(engine.ReplaceTokens(Text), engine.PrintFont, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.PrintBrush, elementBounds.Left, yPos, new StringFormat()); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								The PrintEngine.ReplaceTokens will be used to change the value of special 
								fields that we can place in the text. This will let us create a header that 
								automatically contains the page number, and we could extend this to include 
								things like the current date time, user, computer name and so on. We'll seem 
								them in action later on.
								<br>
								<br>
								This brings us to the end of building the two primitives, so let's now look at 
								the relationship between PrintElement and classes implementing IPrintPrimitive.
								<br>
								<br>
								<b>Building "PageElement"</b>
								<br>
								<br>
								The PrintElement class describes an element that has to be rendered on the 
								report. Simply, it's a list of primitives together with a collection of method 
								that makes life easier for PrintEngine and for the other classes like Customer.
								<br>
								<br>
								Create a new class called PrintElement and add these using statements:
								<br>
								<br>
								<span class="bodyCode">using System; <br>using System.Collections; <br>using System.Drawing; <br>using System.Drawing.Printing;</span>
								<br>
								<br>
								We'll need a member for holding a list of primitives, and also a member for 
								holding a reference to an object supporting IPrintable:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;public class PrintElement <br>&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;// members... <br>&nbsp;&nbsp;&nbsp;&nbsp;private ArrayList _printPrimitives = new ArrayList(); <br>&nbsp;&nbsp;&nbsp;&nbsp;private IPrintable _printObject; <br><br>&nbsp;&nbsp;&nbsp;&nbsp;public PrintElement(IPrintable printObject) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_printObject =  printObject; <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								When we want to print the element (i.e. we want to create a list of primitives 
								that we can then ask each of them to draw themselves on the screen or printer) 
								we'll call a method called Print. This will simply call through _printObject to 
								whatever object is underneath it, in this case Customer.
								<br>
								<br>
								When Customer is asked to print it will call methods like PrintElement.AddText 
								and PrintElement.AddHeader. Let's look at the first of these now:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// AddText - add text to the element... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void AddText(String buf) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// add the text... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddPrimitive(new PrintPrimitiveText(buf)); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								The AddPrimitive simply adds an object supporting IPrintPrimitive to the 
								_printPrimitives list. We'll define this as a public method so that if anyone 
								wants to build more objects that support IPrintPrimitive, or inherit from 
								objects that already do, they'll be able to extend the framework.
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// AddPrimitive - add a primitive to the list... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void AddPrimitive(IPrintPrimitive primitive) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// add it... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_printPrimitives.Add(primitive); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								Here are some more methods that let the developer build up the primitives that 
								make up the element:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// AddData - add data to the element... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void AddData(String dataName, String dataValue) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// add this data to the collection... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddText(dataName + ": " + dataValue); <br>&nbsp;&nbsp;&nbsp;&nbsp;} <br><br>&nbsp;&nbsp;&nbsp;&nbsp;// AddHorizontalRule - add a rule to the element... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void AddHorizontalRule() <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// add a rule object... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddPrimitive(new PrintPrimitiveRule()); <br>&nbsp;&nbsp;&nbsp;&nbsp;} <br><br>&nbsp;&nbsp;&nbsp;&nbsp;// AddBlankLine - add a blank line... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void AddBlankLine() <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// add a blank line... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddText(""); <br>&nbsp;&nbsp;&nbsp;&nbsp;} <br><br>&nbsp;&nbsp;&nbsp;&nbsp;// AddHeader - add a header... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void AddHeader(String buf) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddText(buf); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddHorizontalRule(); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								The PrintEngine is going to need to efficiently calculate the height of the 
								element. It will do this through a call to CalculateHeight and this method 
								simply aggregates the results for calling CalculateHeight on each of the 
								primitives.
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;public float CalculateHeight(PrintEngine engine, Graphics graphics) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// loop through the print height... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float height = 0; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach(IPrintPrimitive primitive in _printPrimitives) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// get the height... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height += primitive.CalculateHeight(engine, graphics); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// return the height... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return height; <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								Finally, the element is going to need to draw itself. This is just a case of 
								iterating through the primitives and asking each one to draw themselves. As 
								part of this job, the element needs to calculate a rectangle that bounds the 
								element.
								<br>
								<br>
								When we call PrintElement.Draw we'll provide a rectangle that describes the 
								area of the page that can be printed on, saving for the space required for the 
								header and the footer.
								<br>
								<br>
								As we mentioned, yPos describes the top y-coordinate of where drawing should be 
								done. As we move through each primitive, we move yPos down to the bottom of the 
								last primitive we drew. (We're not going to allow primitives to overlap, but 
								there's no reason why you couldn't add this functionality to your own 
								implementation.) PrintEngine is going to handle the pagination, so we don't 
								need to worry about whether or not we can fit the element onto the page.
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// Draw - draw the element on a graphics object... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void Draw(PrintEngine engine, float yPos, Graphics graphics, Rectangle pageBounds) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// where... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float height =   CalculateHeight(engine, graphics); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rectangle
elementBounds = new Rectangle(pageBounds.Left, (int)yPos,
pageBounds.Right - pageBounds.Left, (int)height); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// now, tell the primitives to print themselves... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach(IPrintPrimitive primitive in _printPrimitives) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// render it... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primitive.Draw(engine, yPos, graphics, elementBounds); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// move to the next line... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yPos += primitive.CalculateHeight(engine, graphics); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								To round of this section, let's see how we can change Customer so that the 
								primitives are created.
								<br>
								<br>
								<b>Printing Customer Details</b>
								<br>
								<br>
								Go back to Customer.cs and add this code to Print:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// Print... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void Print(PrintElement element) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// tell the engine to draw a header... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.AddHeader("Customer"); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// now, draw the data... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.AddData("Customer ID", Id.ToString()); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.AddData("Name", FirstName + " " + LastName); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.AddData("Company", Company); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.AddData("E-mail", Email); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.AddData("Phone", Phone); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// finally, add a blank line... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.AddBlankLine(); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								As you can see, the work that the developer has to do to get an object to 
								support printing in a report is pretty minimal. She never has to worry about 
								things like pagination, fonts or layout. Instead, she just called methods on 
								PrintElement that add primitives to the page. Now we're at a point where we 
								have an object called Customer that can describe itself on a report by calling 
								methods on an object called PrintElement. Now all we have to do is arrange the 
								elements on the page, handle pagination, deal with headers and footers, provide 
								print preview functionality and actually send the data to the printer. Thanks 
								to the work that's been done with the Framework, this is perhaps the easiest 
								part of the exercise.
								<br>
								<br>
								<b>More Members</b>
								<br>
								<br>
								We're going to need to add more members to the PrintEngine class:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;public class PrintEngine : PrintDocument <br>&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;// members... <br>&nbsp;&nbsp;&nbsp;&nbsp;private ArrayList _printObjects = new ArrayList(); <br>&nbsp;&nbsp;&nbsp;&nbsp;public Font PrintFont = new Font("Arial", 10); <br>&nbsp;&nbsp;&nbsp;&nbsp;public Brush PrintBrush = Brushes.Black; <br>&nbsp;&nbsp;&nbsp;&nbsp;public PrintElement Header; <br>&nbsp;&nbsp;&nbsp;&nbsp;public PrintElement Footer; <br>&nbsp;&nbsp;&nbsp;&nbsp;private ArrayList _printElements; <br>&nbsp;&nbsp;&nbsp;&nbsp;private int _printIndex = 0; <br>&nbsp;&nbsp;&nbsp;&nbsp;private int _pageNum = 0;</span>
								<br>
								<br>
								The PrintFont and PrintBrush will be used to define the font and brush that 
								will be used to do the printing. In this case, we're saying that we want to use 
								a ten point Arial font, in black.
								<br>
								<br>
								The Header and Footer describe elements that contain the header and footer for 
								each page. _printElements describes a list of all the elements, except Header 
								and Footer. _printIndex keeps track of the current position in the 
								_printElements list. Finally, _pageNum keeps track of the current page number.
								<br>
								<br>
								The first thing to do before we try to print is build up the header and footer 
								elements. We'll create default ones in the constructor:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;public PrintEngine() <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create the header... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Header = new PrintElement(null); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Header.AddText("Report"); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Header.AddText("Page: [pagenum]"); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Header.AddHorizontalRule(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Header.AddBlankLine(); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create the footer... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Footer = new PrintElement(null); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Footer.AddBlankLine(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Footer.AddHorizontalRule(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Footer.AddText("Confidential"); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								The easiest way to develop printing routines is to get the print preview 
								working. This saves a lot of otherwise wasted paper! Luckily for us, the 
								Framework provides a class that containerizes an instance of 
								PrintPreviewControl. Add this method to PrintEngine:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// ShowPreview - show a print preview... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void ShowPreview() <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// now, show the print dialog... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PrintPreviewDialog dialog = new PrintPreviewDialog(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dialog.Document =  this; <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// show the dialog... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dialog.ShowDialog(); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								As you can see, PrintPreviewDialog needs to be given a PrintDocument object, so 
								we give it a reference to the PrintEngine object that was used. We then call 
								ShowDialog.
								<br>
								<br>
								The printing routines have a fairly curious way of working, which I mentioned 
								right at the beginning involved firing events to signal when a page needs to be 
								printed. The first event that gets fired is BeginPrint, but as PrintEngine is 
								inherited from PrintDocument the best way to get at this is to override 
								OnBeginPrint. This is, I'm told, similar to the way that the printing routines 
								in MFC worked.
								<br>
								<br>
								What we need to do in response to this event is create a new list of 
								PrintElement objects - one for each of the objects we have in our _printObjects 
								list. Add this code to PrintEngine:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// OnBeginPrint - called when printing starts <br>&nbsp;&nbsp;&nbsp;&nbsp;protected override void OnBeginPrint(PrintEventArgs e) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// reset... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_printElements =  new ArrayList(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_pageNum = 0; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_printIndex = 0; <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// go through the objects in the list and create print elements for each one... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach(IPrintable printObject in _printObjects) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create an element... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PrintElement element = new PrintElement(printObject); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_printElements.Add(element); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// tell it to print... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.Print(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								As we work through the list we create a new PrintElement object for each 
								IPrintable -supporting object that we have. We then ask each element to print 
								itself through the Print method. At this time, the element will call into 
								IPrintable.Print and the underlying class will tall the various AddText, 
								AddHeader, AddHorizontalRule methods to build up the primitives.
								<br>
								<br>
								Once we've done that, we can turn our attention to the printing mechanism. This 
								is done through OnPrintPage. Add this code:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// OnPrintPage - called when printing needs to be done... <br>&nbsp;&nbsp;&nbsp;&nbsp;protected override void OnPrintPage(PrintPageEventArgs e) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// adjust the page number... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_pageNum++;</span>
								<br>
								<br>
								The first thing we do is increment the page number. In OnBeginPrint we set this 
								to 0, meaning that on the first page it will be 1. We then want to draw the 
								header element. This will always appear in the top-left hand corner of each 
								page.
								<br>
								<br>
								The PrintPageEventArgs contains members that tell us everything we need to know 
								about printing. MarginBounds describes a rectangle containing the printable 
								area of the page. Graphics contains a System.Graphics.Drawing object that 
								contains the methods necessary for drawing on the screen or printer. We pass 
								both of these into the header element:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// now, render the header element... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float headerHeight = Header.CalculateHeight(this, e.Graphics); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Header.Draw(this, e.MarginBounds.Top, e.Graphics, e.MarginBounds); <br>Drawing the footer is a similar deal, except this has to appear at the bottom of the page: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// also, we need to calculate the footer height... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float footerHeight = Footer.CalculateHeight(this, e.Graphics); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Footer.Draw(this, e.MarginBounds.Bottom - footerHeight, e.Graphics, e.MarginBounds);</span>
								<br>
								<br>
								Once we've done that, we need to calculate the area of the page that's left. 
								This will contain the elements, or rather as many elements as will fit onto the 
								page.
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// now we know the header and footer, we can adjust the page bounds... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rectangle pageBounds = new Rectangle(e.MarginBounds.Left, <br>&nbsp;&nbsp;(int)(e.MarginBounds.Top + headerHeight), e.MarginBounds.Width, <br>&nbsp;&nbsp;&nbsp;&nbsp;(int)(e.MarginBounds.Height - footerHeight - headerHeight)); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yPos = pageBounds.Top;</span>
								<br>
								<br>
								Right at the end there we define and set yPos to be the top of the printable 
								area given over to elements. We'll see how this moves down the page as we draw 
								elements.
								<br>
								<br>
								The _printIndex keeps track of which element has to be drawn next. In 
								OnBeginPage we set this to 0 meaning that the next element we draw will be the 
								first one in _printElements. To loop through the elements, we need to do this:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ok, now we need to loop through the elements... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool morePages =   false; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int elementsOnPage = 0; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(_printIndex &lt; _printElements.Count) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// get the element... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PrintElement element = (PrintElement)_printElements[_printIndex];</span>
								<br>
								<br>
								Once we have the element, we need to find its height. Taking into consideration 
								the current position of yPos, we want to make sure that the element will fit on 
								the page:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// how tall is the primitive? <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float height = element.CalculateHeight(this, e.Graphics); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// will it fit on the page? <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(yPos + height &gt; pageBounds.Bottom) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;// we don't want to do this if we're the first thing on the page... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(elementsOnPage != 0) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;morePages = true; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								If the element will not fit on the page, we quit the loop - and we'll see why 
								in a moment. One important thing to note here is that if this is the first 
								element on the page (i.e. elementsOnPage = 0), we never want to leave the loop. 
								If it's the first element and it's the first page, it's too big to fit on any 
								page. Rather than breaking the element up, we'll just render it as it is, 
								meaning that the bottom of the element will draw over the footer.
								<br>
								<br>
								Providing the element will fit, we can tell the element to draw itself, move 
								yPos down to the position of the next element and adjust printIndex so that it 
								points to the next element in the list:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// now draw the element... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.Draw(this, yPos, e.Graphics, pageBounds); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// move the ypos... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yPos += height; <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// next... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_printIndex++; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elementsOnPage++; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								So what happens if we have more pages? Well, we have to set 
								PrintPageEventArgs.HasMorePages to true. This will result on OnPrintPage being 
								called a second time, in which case we go round the whole thing again:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do we have more pages? <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.HasMorePages =  morePages; <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								<b>Replacing Tokens</b>
								<br>
								<br>
								When we built our header element we added a line like this:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Header.AddText("Page: [pagenum]");</span>
								<br>
								<br>
								The [pagenum] represents a token that we want to replace at print time with a 
								value of some kind, in this case the current page number. When we created the 
								PrintPrimitiveText class, we had this calling into PrintEngine.ReplaceTokens 
								before the text was sent to the printer. Add this method to PrintEngine:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// ReplaceTokens - take a string and remove any tokens replacing them with values... <br>&nbsp;&nbsp;&nbsp;&nbsp;public String ReplaceTokens(String buf) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// replace... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf =  buf.Replace("[pagenum]", _pageNum.ToString()); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// return... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return buf; <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								Although we've just shown how to replace [pagenum] here, the same will work 
								with other tokens that you define.
								<br>
								<br>
								<b>Calling "ShowPrintPreview"</b>
								<br>
								<br>
								To call ShowPrintPreview, we actually need something to print. Add this member 
								to Form1:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;public class Form1 : System.Windows.Forms.Form <br>&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;// members... <br>&nbsp;&nbsp;&nbsp;&nbsp;PrintEngine _engine = new PrintEngine();</span>
								<br>
								<br>
								In response to changing the slider value, we want to add Customer objects to 
								_engine. Add this line to Form1 's constructor:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;public Form1() <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Required for Windows Form Designer support <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InitializeComponent(); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create a default print engine... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateEngine(1); <br>&nbsp;&nbsp;&nbsp;&nbsp;} <br>Now, add this definition for CreateEngine: <br>&nbsp;&nbsp;&nbsp;&nbsp;// CreateEngine - create a print engine and populate it with customers... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void CreateEngine(int numCustomers) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create a new engine... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_engine = new PrintEngine(); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// loop through the customers... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int n = 0; n &lt; numCustomers; n++) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create the customer... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Customer theCustomer = new Customer(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theCustomer.Id = n + 1; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theCustomer.FirstName = "Darren"; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theCustomer.LastName = "Clarke"; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theCustomer.Company = "Madras inc."; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theCustomer.Email = "darren@pretendcompany.com"; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theCustomer.Phone = "602 555 1234"; <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// add the customer to the list... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_engine.AddPrintObject(theCustomer); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								There's nothing very complicated about this. All we want to do is create 
								Customer objects and add them to the engine.
								<br>
								<br>
								Next, add this event handler to make calls to CreateEngine whenever the user 
								changes the slider value:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;private void trackCustomers_Scroll(object sender, System.EventArgs e) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateEngine(trackCustomers.Value); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								Finally, we can wire up cmdPrintPreview_click:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;private void cmdPrintPreview_Click(object sender, System.EventArgs e) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// tell the print object to display a preview... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_engine.ShowPreview(); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								Now we can try running the application and testing the print preview. Leave the 
								slider where it is and click the button. You should see something like this:
								<br>
								<br>
								<div align="center"><img alt="Screenshot" src="index2.php_files/print_csharp_4.gif"></div>
								<br>
								<br>
								Zooming in, you should see this:
								<br>
								<br>
								<div align="center"><img alt="Screenshot" src="index2.php_files/print_csharp_5.gif"></div>
								<br>
								<br>
								Now, close the print preview and change the slider to about a third of the way 
								along. This will create a bundle of Customer objects and you should see more 
								pages on the preview.
								<br>
								<br>
								<div align="center"><img alt="Screenshot" src="index2.php_files/print_csharp_6.gif"></div>
								<br>
								<br>
								That's the basics of printing illustrated. You can actually print the document 
								if you want by clicking the printer button on the toolbar. When printing, you 
								might want to change some of the page settings. You might want to use a 
								different page size or a landscape orientation.
								<br>
								<br>
								The Framework provides a class that lets you change the layout of the page. The 
								PrintDocument class has a property called DefaultPageSettings. This contains 
								the current settings for the page, and when the object is created this is 
								populated with the default page settings for the default printer.
								<br>
								<br>
								Add this method to PrintEngine:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// ShowPageSettings - let's us change the page settings... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void ShowPageSettings() <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PageSetupDialog setup = new PageSetupDialog(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PageSettings settings = DefaultPageSettings; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setup.PageSettings = settings; <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// display the dialog and, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(setup.ShowDialog() == DialogResult.OK) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DefaultPageSettings = setup.PageSettings; <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								This method will take the current page settings from the dialog and invite the 
								user to change them. If the user presses OK on the dialog, the changes settings 
								are saved.
								<br>
								<br>
								Add this event handler to Form1 to finish this off:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;private void cmdPageSettings_Click(object sender, System.EventArgs e) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// show the page settings... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_engine.ShowPageSettings(); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								If you try this, remember that if you change the slider you'll lose the page 
								settings. (i.e. if you start the application check the print preview, close it 
								down, change the page settings, change the slider and then view the print 
								preview, the page settings will not be saved as a new instance of PrintEngine 
								would have been created.) You should see something like this:
								<br>
								<br>
								<div align="center"><img alt="Screenshot" src="index2.php_files/print_csharp_7.gif"></div>
								<br>
								<br>
								<span class="headBlueSmall">Printing Without the Preview</span>
								<br>
								<br>
								To print to another printer, you have to use the standard print dialog. We can 
								bring this up in much the same way, so add this method to PrintEngine:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;// ShowPrintDialog - display the print dialog... <br>&nbsp;&nbsp;&nbsp;&nbsp;public void ShowPrintDialog() <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create and show... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PrintDialog dialog = new PrintDialog(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dialog.PrinterSettings = PrinterSettings; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dialog.Document =  this; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(dialog.ShowDialog() == DialogResult.OK) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// save the changes... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PrinterSettings = dialog.PrinterSettings; <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do the printing... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								<br>
								<br>
								Again, if the user clicks OK we save the settings, but this time we also call 
								Print to print directly to the configured printer. Add this event handler to 
								Form1 to finish this off:
								<br>
								<br>
								<span class="bodyCode">&nbsp;&nbsp;&nbsp;&nbsp;private void cmdPrint_Click(object sender, System.EventArgs e) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// print... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_engine.ShowPrintDialog(); <br>&nbsp;&nbsp;&nbsp;&nbsp;}</span>
								In this exercise we built a fairly complete example of how to build a C# 
								desktop application with print capabilities. We architected the solution using 
								a flexible combination of elements and primitives meaning that developers 
								wishing to extend the printing functionality down the line would be able to do 
								so easily.<br>
								<table class="contentpaneopen" bgcolor="#eeeeee" cellpadding="0" cellspacing="3" width="100%">
									<tbody>
										<tr>
											<td>
												<b>DISCLAIMER:</b> The content provided in this article is not warranted or 
												guaranteed by Developer Shed, Inc. The content provided is intended for 
												entertainment and/or educational purposes in order to introduce to the reader 
												key ideas, concepts, and/or product reviews. As such it is incumbent upon the 
												reader to employ real-world tactics for security and implementation of best 
												practices. We are not liable for any negative consequences that may result from 
												implementing any information covered in our articles or tutorials. If this is a 
												hardware review, it is not recommended to open and/or modify your hardware.
											</td>
										</tr>
									</tbody></table>
							</div>
						</span>
					</td>
				</tr>
			</tbody></table>
	</body>
</html>
